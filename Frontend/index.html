<!-- Save this as index.html and run with python -m http.server 8000 inside the folder -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Car Showroom</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #upload-container { position: absolute; top: 20px; left: 20px; z-index: 200; }
    #upload-container input, #upload-container button { margin: 4px; padding: 6px; }

    #car-name {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 16px;
      border-radius: 8px; font-size: 20px; z-index: 200;
    }

    #tooltip {
      position: absolute; background: rgba(0, 0, 0, 0.8); color: white;
      padding: 4px 8px; border-radius: 4px; display: none;
      pointer-events: none; z-index: 150;
    }

    #feature-description {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: white; padding: 10px 20px; border-radius: 10px;
      font-size: 16px; color: black; display: none; z-index: 150;
      max-width: 60%; text-align: center;
    }
  </style>
</head>
<body>
  <div id="upload-container">
    <input type="file" id="brochure" accept=".pdf" />
    <button id="uploadBtn">Upload Brochure</button>
  </div>
  <div id="car-name">Upload brochure to begin</div>
  <div id="tooltip"></div>
  <div id="feature-description"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minPolarAngle = Math.PI / 2.2;
    controls.maxPolarAngle = Math.PI / 2.2;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const tooltip = document.getElementById('tooltip');
    const desc = document.getElementById('feature-description');
    const carName = document.getElementById('car-name');

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let featureDots = [];
    let carInfo = null;
    let modelGroup = new THREE.Group();

    const featureDescriptions = {
      "alloy wheels": "Stylish and lightweight wheels that enhance performance.",
      "led tail lamps": "Brighter, longer-lasting tail lights for better visibility.",
      "projector headlamps": "Focused lighting for improved nighttime driving.",
      "cruise control": "Maintains your speed automatically for long trips.",
      "rear ac vent": "Air conditioning vents for rear passengers.",
      "voice recognition": "Use your voice to control car features.",
      "hill-start assist": "Prevents rollback when starting on a slope.",
      "touchscreen": "Central display for controls and media.",
      "airbags": "Inflate during collisions to protect passengers.",
      "rear parking camera": "Displays rear view when reversing."
    };

    document.getElementById('uploadBtn').addEventListener('click', async () => {
      const fileInput = document.getElementById('brochure');
      const file = fileInput.files[0];
      if (!file) return alert("Please choose a PDF file.");

      const formData = new FormData();
      formData.append("pdf", file);

      try {
        carName.innerText = "Uploading and processing (this may take 15–30 seconds)...";
        const response = await fetch("http://127.0.0.1:5000/upload", {
          method: "POST",
          body: formData
        });

        if (!response.ok) throw new Error("Upload failed with status " + response.status);
        await response.json();
        carName.innerText = "Processing completed!";
        await loadCarInfoAndModel();
      } catch (err) {
        console.error("❌ Upload error:", err);
        carName.innerText = "Upload failed!";
        alert("Upload or processing error: " + err.message);
      }
    });

    async function loadCarInfoAndModel() {
      featureDots.forEach(dot => scene.remove(dot));
      featureDots = [];
      scene.remove(modelGroup);
      modelGroup = new THREE.Group();
      scene.add(modelGroup);

      const res = await fetch("car_info.json");
      carInfo = await res.json();
      carName.innerText = carInfo.name?.toUpperCase() || "CAR NAME";

      const loader = new GLTFLoader();
      loader.setPath("./models/");
      loader.load("scene.gltf", (gltf) => {
        const model = gltf.scene;
        model.rotation.set(-Math.PI / 2, 0, 0);

        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const scale = 6 / Math.max(size.x, size.y, size.z);
        model.scale.setScalar(scale);

        const newBox = new THREE.Box3().setFromObject(model);
        const minY = newBox.min.y;
        const finalCenter = newBox.getCenter(new THREE.Vector3());

        model.position.set(-finalCenter.x, -minY, -finalCenter.z);
        modelGroup.add(model);

        camera.position.set(0, newBox.getSize(new THREE.Vector3()).y * 0.7, newBox.getSize(new THREE.Vector3()).z * 1.8);
        controls.target.set(0, newBox.getSize(new THREE.Vector3()).y * 0.5, 0);
        controls.update();

        addFeatureDots(scale);
      });
    }

    function addFeatureDots(scale) {
  const dotGeometry = new THREE.SphereGeometry(0.12, 16, 16);
  const dotMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

  const box = new THREE.Box3().setFromObject(modelGroup);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const min = box.min;
  const max = box.max;

  const featureOffsets = {
    "alloy wheels": new THREE.Vector3(0.45 * size.x, 0.2 * size.y, 0.4 * size.z),
    "led tail lamps": new THREE.Vector3(0, 0.4 * size.y, -0.5 * size.z),
    "projector headlamps": new THREE.Vector3(0, 0.5 * size.y, 0.5 * size.z),
    "cruise control": new THREE.Vector3(0.2 * size.x, 0.65 * size.y, 0.1 * size.z),
    "rear ac vent": new THREE.Vector3(0, 0.6 * size.y, -0.1 * size.z),              // lifted
    "voice recognition": new THREE.Vector3(0.1 * size.x, 0.65 * size.y, 0),
    "hill-start assist": new THREE.Vector3(-0.3 * size.x, 0.35 * size.y, -0.2 * size.z),
    "touchscreen": new THREE.Vector3(0, 0.65 * size.y, 0.2 * size.z),               // lifted forward
    "airbags": new THREE.Vector3(0.3 * size.x, 0.7 * size.y, 0.2 * size.z),         // higher + forward
    "rear parking camera": new THREE.Vector3(0, 0.35 * size.y, -0.55 * size.z)
  };

  Object.keys(featureDescriptions).forEach(feature => {
    const offset = featureOffsets[feature];
    if (offset) {
      const dot = new THREE.Mesh(dotGeometry, dotMaterial);
      const position = new THREE.Vector3(
        center.x + offset.x,
        min.y + offset.y + 0.07, // float slightly higher
        center.z + offset.z
      );
      dot.position.copy(position);
      dot.userData.feature = feature;
      modelGroup.add(dot);
      featureDots.push(dot);
    } else {
      console.warn("⚠️ No position defined for feature:", feature);
    }
  });
}



    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(featureDots);
      if (intersects.length > 0) {
        const feature = intersects[0].object.userData.feature;
        tooltip.innerText = feature;
        tooltip.style.left = `${event.clientX + 10}px`;
        tooltip.style.top = `${event.clientY - 30}px`;
        tooltip.style.display = "block";
      } else {
        tooltip.style.display = "none";
      }
    }

    function onClick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(featureDots);
      if (intersects.length > 0) {
        const feature = intersects[0].object.userData.feature;
        desc.innerText = `${feature.toUpperCase()}: ${featureDescriptions[feature] || "Description not available."}`;
        desc.style.display = "block";
      } else {
        desc.style.display = "none";
      }
    }

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("click", onClick);
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
